ReDuxml brings XML to life by allowing users to parameterize content
using a simple syntax requiring no more than middle-school-level math
to make design data captured by XML dynamic. The resulting designs can 
then be used to generate further designs by setting parameter values and
running #resolve. Content reuse within complex designs can multiply, 
vastly reducing the size and complexity of projects.
To illustrate:

`load 'file.xml'`
`doc.to_s           => '<root>
                        <parameters><parameter name="foo" value="10"/></parameters>
                        <should if="@(foo == 10")>i stay or</should>
                        <should if="@(foo == 9)">i go now?</should></root>'
resolve doc         => '<root>
                       <should>i stay or</should>
                       </root>'
reduxes             => [#<Duxml::Doc>,#<Duxml::Doc>] # now tracking two documents, the original, and the permutation where foo == 10
doc.parameters[:foo] = 9 => #<ReDuxml::ParameterClass>
resolve doc         => '<root>
                        <should>i go now</should
                        </root>
reduxes             => [#<Duxml::Doc>,#<Duxml::Doc>,#<Duxml::Doc>]
`

You can also create an Evaluator object that can evaluate parameterized 
strings, i.e. Macro objects, using operator properties from three 
sources, in order:
logic.xml
Symbolic gem
Ruby

So a simple logical expression involving basic arithmetic can include
unknown values and still be evaluated, e.g:
`e = Evaluator.new('logic.xml')           => #<Evaluator>
 e.evaluate('(2x - x) < y')               => 'x < y'
 e.evaluate('(2x - x) < y', {y: x})       => false
 e.evaluate('(2x - x) < y', {x: 0, y: 1}) => true
                        `
