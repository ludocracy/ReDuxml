<?xml version="1.0" encoding="UTF-8" ?>
<crr:UniversalDevice xmlns:crr="http://apif.freescale.net/schemas/regs/1.2"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://apif.freescale.net/schemas/regs/1.2 
                http://apif.freescale.net/schemas/regs/1.2/regs.xsd">
  <creation_info author="$Author: b35396 $" date="$Date: Mon Dec 15 09:52:23 2014 $"
    revision="$Revision: 1.6 $"
    source="$Source: /sync/vault/15001/sv/Projects/DN_Docs_D4E_sandbox/crr_docs/proposals/crr_1_0.dita.rca $"/>
  <GeneralPeriphery>
    <GeneralParameters>
      <instance_header>
        <instance_description>test_inst_descr</instance_description>
        <instance_long_description>
          <p>Long description of this test module. XML content is allowed here.</p>
        </instance_long_description>
        <template_parameters>
          <!-- PK: your design and docs parameters are declared here; note that without default values you cannot generate instantiated output without .params or .instlst overrides to supply parameter values -->
          <bool_template_parameter name="internal" default="true"/>

          <include_template_parameters file="test.paramdef"/>
        </template_parameters>
      </instance_header>
      <general_parameter_defs>
        <string_general_parameter name="peripheralType" value="test_peripheral_type"
          description="Peripheral/Component Type"/>
      </general_parameter_defs>
    </GeneralParameters>
    <register_defs>
      <address_block byte_order="bigEndian" lau="16" name="test_address_block">
        <base_address/>
        <bit_order order="lsb0"/>
        <!-- tests user-defined iterators -->
        <register_array name="test_array" size="16">
          <autoinc_address offset="0x0" step="4"/>
          <int_iterator name="int0" display_letter="x"/>
          <int_iterator name="int1" from="5" display_letter="y"/>
          <char_iterator from="A" name="char" display_letter="n"/>
          <register_def name="test@[int0]_@[char]" id="test@[int0]_@[char]" width="32">
            <brief_description>from 5: @[int1]; from 0: @[int0]; char: @[char]</brief_description>
            <address offset="0x0"></address>
            <reserved_bit_field width="6" access="ROZ" position="0"><reset_value value="0"/></reserved_bit_field>
            <bit_field position="6" width="26" access="RW" id="test_bf" name="test_bf"><reset_value value="undefined"></reset_value></bit_field>
          </register_def>
        </register_array>
        <!-- tests if xrefs break when step is greater than 4 and/or array is interleaved with another array 
          <register_array name="memory_map_xref_test_array" size="3">
          <autoinc_address offset="0x0" step="8"/>
          <int_iterator name="i"/>
        <register_def name="test_split_array_reg@[i]" id="test_split_array_reg@[i]" width="32">
          <brief_description></brief_description>
          <address offset="0x0"/>
          <bit_field position="0" width="32" access="RW" id="test_bf" name="test_bf"/>
        </register_def></register_array>-->
        <!-- tests alternate registers -->
        <!--<alternate_register_groups name="PCI_Compatible_Registers_Type_Specific">
          <address offset="0"/>
          <group_selector register="Header_Type_Register" bit_field="Header_Layout"/>
          <register_group name="Type0">
            <group_selector bit_field_value="0x0"/>
            <register_def name="BAR1" id="BAR1" width="32" >
              <brief_description>PCI Express Base Address Register 1</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>Base address register 1 at offset 0x14 is used to define the inbound memory window in the 32-bit memory space.
                </p>
              </long_description>
              <address offset="0x14"/>
              <reset_value value="0x9"/>
              <bit_field name="MemSp" id="MemSp" position="0" width="1" access="RW">
                <brief_description>Memory space indicator</brief_description>
                <long_description>
                  <p>Base Address registers that map to Memory Space must return a 0 in bit 0.</p>
                  <p>Base Address registers that map to I/O Space must return a 1 in bit 0.</p>
                </long_description>
              </bit_field>
              <bit_field name="TYPE" id="TYPE" position="1" width="2" access="RW">
                <brief_description>Type</brief_description>
                <long_description/>
                <bit_field_value value="0b00">
                  <brief_description>Locate anywhere in 32-bit address space.</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="PREF" id="PREF" position="3" width="1" access="RW">
                <brief_description>Prefetchable</brief_description>
                <long_description >
                  <p>This bit is determined by PEXIWAR1[PF].</p>
                </long_description>
              </bit_field>
              <reserved_bit_field position="4" width="8" access="RU">
                <long_description>
                  <p>Reserved. The device allows a 4 Kbyte window minimum.</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="ADDRESS" id="ADDRESS" position="12" width="20" access="RW">
                <brief_description>Base address</brief_description>
                <long_description>
                  <p>Indicates the base address where the inbound memory window begins. 
                  </p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="BAR2" id="BAR2" width="32" >
              <brief_description>PCI Express Base Address Register 2</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>Base address register 2 at offset 0x18 and base address register 4 at offset 0x20 are used to define the lower
                  portion of the 64-bit inbound memory windows. </p>
              </long_description>
              <address offset="0x18"/>
              <reset_value value="0xC"/>
              <bit_field name="MemSp" id="MemSp" position="0" width="1" access="RW">
                <brief_description>Memory space indicator</brief_description>
                <long_description>
                  <p>Base Address registers that map to Memory Space must return a 0 in bit 0.</p>
                  <p>Base Address registers that map to I/O Space must return a 1 in bit 0.</p>
                </long_description>
              </bit_field>
              <bit_field name="TYPE" id="TYPE" position="1" width="2" access="RW">
                <brief_description>Type</brief_description>
                <long_description/>
                <bit_field_value value="0b00">
                  <brief_description>Locate anywhere in 32-bit address space.</brief_description>
                </bit_field_value>
                <bit_field_value value="0b10">
                  <brief_description>Locate anywhere in 64-bit address space.</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="PREF" id="PREF" position="3" width="1" access="RW">
                <brief_description>Prefetchable</brief_description>
                <long_description >
                  <p>This bit is determined by PEXIWARn[2].</p>
                </long_description>
              </bit_field>
              <reserved_bit_field position="4" width="8" access="RU">
                <long_description>
                  <p>Reserved. The device allows a 4 Kbyte window minimum.</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="ADDRESS" id="ADDRESS" position="12" width="20" access="RW">
                <brief_description>Base address (lower portion)</brief_description>
                <long_description>
                  <p>Indicates the lower portion of the base address where the inbound memory window begins. 
                  </p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="BAR3" id="BAR3" width="32" >
              <brief_description>PCI Express Base Address Register 3</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>Base address register 3 at offset 0x1C and base address register 5 at offset 0x24 are used to define the upper
                  portion of the 64-bit inbound memory windows. </p>
              </long_description>
              <address offset="0x1C"/>
              <reset_value value="0x0"/>
              <bit_field name="ADDRESS" id="ADDRESS" position="0" width="32" access="RW">
                <brief_description>Base address (upper portion)</brief_description>
                <long_description>
                  <p>Indicates the upper portion of the base address where the inbound memory window begins.  If no access to local memory is to be permitted by external requesters, then all bits are
                    programmed. </p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="BAR4" id="BAR4" width="32" >
              <brief_description>PCI Express Base Address Register 4</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>Base address register 2 at offset 0x18 and base address register 4 at offset 0x20 are used to define the lower
                  portion of the 64-bit inbound memory windows. </p>
              </long_description>
              <address offset="0x20"/>
              <reset_value value="0xC"/>
              <bit_field name="MemSp" id="MemSp" position="0" width="1" access="RW">
                <brief_description>Memory space indicator</brief_description>
                <long_description>
                  <p>Base Address registers that map to Memory Space must return a 0 in bit 0.</p>
                  <p>Base Address registers that map to I/O Space must return a 1 in bit 0.</p>
                </long_description>
              </bit_field>
              <bit_field name="TYPE" id="TYPE" position="1" width="2" access="RW">
                <brief_description>Type</brief_description>
                <long_description/>
                <bit_field_value value="0b00">
                  <brief_description>Locate anywhere in 32-bit address space.</brief_description>
                </bit_field_value>
                <bit_field_value value="0b10">
                  <brief_description>Locate anywhere in 64-bit address space.</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="PREF" id="PREF" position="3" width="1" access="RW">
                <brief_description>Prefetchable</brief_description>
                <long_description >
                  <p>This bit is determined by PEXIWARn[2].</p>
                </long_description>
              </bit_field>
              <reserved_bit_field position="4" width="8" access="RU">
                <long_description>
                  <p>Reserved. The device allows a 4 Kbyte window minimum.</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="ADDRESS" id="ADDRESS" position="12" width="20" access="RW">
                <brief_description>Base address (lower portion)</brief_description>
                <long_description>
                  <p>Indicates the lower portion of the base address where the inbound memory window begins. 
                  </p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="BAR5" id="BAR5" width="32" >
              <brief_description>PCI Express Base Address Register 5</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>Base address register 3 at offset 0x1C and base address register 5 at offset 0x24 are used to define the upper
                  portion of the 64-bit inbound memory windows. </p>
              </long_description>
              <address offset="0x24"/>
              <reset_value value="0x0"/>
              <bit_field name="ADDRESS" id="ADDRESS" position="0" width="32" access="RW">
                <brief_description>Base address (upper portion)</brief_description>
                <long_description>
                  <p>Indicates the upper portion of the base address where the inbound memory window begins. If no access to local memory is to be permitted by external requestors, then all bits are
                    programmed. </p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Subsystem_Vendor_ID_Register" id="Subsystem_Vendor_ID_Register" width="16" >
              <brief_description>PCI Express Subsystem Vendor ID Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>The PCI Express subsystem vendor ID register is used to identify the subsystem.</p>
              </long_description>
              <address offset="0x2C"/>
              <reset_value value="0x0"/>
              <bit_field name="Subsystem_Vendor_ID" id="Subsystem_Vendor_ID" position="0" width="16" access="RO">
                <brief_description>
                  <p>Subsystem Vendor ID</p>
                </brief_description>
                <long_description>
                  <p>This register is present only in the Type 0 Header (EP mode).</p>
                  <p>The PCI Express subsystem vendor ID register is used to identify the subsystem vendor.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Subsystem_ID_Register" id="Subsystem_ID_Register" width="16" >
              <brief_description>PCI Express Subsystem ID Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>The PCI Express subsystem ID register is used to identify the subsystem.</p>
              </long_description>
              <address offset="0x2E"/>
              <reset_value value="0x0"/>
              <bit_field name="Subsystem_ID" id="Subsystem_ID" position="0" width="16" access="RO">
                <brief_description>Subsystem ID</brief_description>
                <long_description/>
              </bit_field>
            </register_def>
            <register_def name="Expansion_ROM_BAR_Type0" id="Expansion_ROM_BAR_Type0" width="32" >
              <brief_description>PCI Express Expansion ROM Base Address Register (EP-Mode)</brief_description>
              <long_description>
                <p>The Expansion ROM Base Address register is located at offset 0x30 in the Type 0 Header (EP mode); it is located
                  at offset 0x38 in the Type 1 Header (RC mode).</p>
                
                
              </long_description>
              <address offset="0x30"/>
              <reset_value value="0x0"/>
              <bit_field name="ROMBAR_EN" id="ROMBAR_EN_T0" position="0" width="1" access="RW">
                <brief_description>Expansion ROM enable</brief_description>
                <long_description>
                  <p>This bit controls whether or not the device accepts accesses to its expansion ROM</p>
                </long_description>
                <bit_field_value value="0b0">
                  <brief_description>The expansion ROM address space is disabled.</brief_description>
                </bit_field_value>
                <bit_field_value value="0b1">
                  <brief_description>Address decoding is enabled.</brief_description>
                </bit_field_value>
              </bit_field>
              <reserved_bit_field position="1" width="10" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="ROM_Base_Address" id="ROM_Base_Address_T0" position="11" width="21" access="RW">
                <brief_description>Expansion ROM base address</brief_description>
                <long_description>
                  <p>Specifies bits 31:11 of the non-prefetchable expansion ROM space start address. Typically used for specifying
                    memory-mapped I/O space. The default size is 16M.</p>
                </long_description>
              </bit_field>
            </register_def>
            <!-\- Need to map the Expansion ROM BAR Mask register into CS2 space
          
          <register_def name="Expansion_ROM_BAR_Mask_Register" id="Expansion_ROM_BAR_Mask_Register" width="32">
          <brief_description>PCI Express Expansion ROM BAR Mask Register</brief_description>
          <long_description>
              PEX_CSR1[CS2]. When PEX_CSR1[CS2] = 1, the register functions as the PCI Express expansion ROM BAR mask register.</p>
              set.</p>
          </long_description>
          <address offset="0x30"/>
          <reset_value value="0xFF000000"/>
          <bit_field name="Address_decode_enable" id="Address_decode_enable" position="0" width="1" access="RW">
            <brief_description>E</brief_description>
            <long_description/>
          </bit_field>
          <reserved_bit_field position="1" width="3" access="RU">
            <long_description>
              <p>Reserved</p>
            </long_description>
          </reserved_bit_field>
          <bit_field name="ROM_Mask" id="ROM_Mask" position="4" width="28" access="RW">
            <brief_description>ROM mask</brief_description>
            <long_description>
              <p>The default mask is 0xFF00000 which is 16 M.</p>
            </long_description>
          </bit_field>
        </register_def>
        
-\->
            <register_def name="Minimum_Grant_Register" id="Minimum_Grant_Register" width="8" >
              <brief_description>PCI Express Minimum Grant Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>This register does not apply to PCI Express. It is present for legacy purposes.</p>
              </long_description>
              <address offset="0x3E"/>
              <reset_value value="0x0"/>
              <bit_field name="MIN_GNT" id="MIN_GNT" position="0" width="8" access="RO">
                <brief_description>Minimum grant</brief_description>
                <long_description>
                  <p>Does not apply for PCI Express.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Maximum_Latency_Register" id="Maximum_Latency_Register" width="8" >
              <brief_description>PCI Express Maximum Latency Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 0 Header (EP mode).</p>
                <p>This register does not apply to PCI Express. It is present for legacy purposes.</p>
              </long_description>
              <address offset="0x3F"/>
              <reset_value value="0x0"/>
              <bit_field name="MAX_LAT" id="MAX_LAT" position="0" width="8" access="RO">
                <brief_description>Maximum latency</brief_description>
                <long_description>
                  <p>Does not apply for PCI Express.</p>
                </long_description>
              </bit_field>
            </register_def>
          </register_group>
          <register_group name="Type1">
            <group_selector bit_field_value="0x1"/>
            <register_def name="Primary_Bus_Number_Register" id="Primary_Bus_Number_Register" width="8">
              <brief_description>PCI Express Primary Bus Number Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x18"/>
              <reset_value value="0x0"/>
              <bit_field name="Primary_Bus_Number" id="Primary_Bus_Number" position="0" width="8" access="RW">
                <brief_description>Primary Bus Number</brief_description>
                <long_description>
                  <p>Bus that is connected to the upstream interface. Note that this register is programmed during system
                    enumeration; in RC mode this register should remain 0x00.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Secondary_Bus_Number_Register" id="Secondary_Bus_Number_Register" width="8">
              <brief_description>PCI Express Secondary Bus Number Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x19"/>
              <reset_value value="0x0"/>
              <bit_field name="Secondary_Bus_Number" id="Secondary_Bus_Number" position="0" width="8" access="RW">
                <brief_description>Secondary Bus Number</brief_description>
                <long_description>
                  <p>Bus that is directly connected to the downstream interface. Note that this register is programmed during system
                    enumeration; in RC mode, this register is typically programmed to 0x01.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Subordinate_Bus_Number_Register" id="Subordinate_Bus_Number_Register" width="8">
              <brief_description>PCI Express Subordinate Bus Number Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x1A"/>
              <reset_value value="0x0"/>
              <bit_field name="Subordinate_Bus_Number" id="Subordinate_Bus_Number" position="0" width="8" access="RW">
                <brief_description>Subordinate Bus Number</brief_description>
                <long_description>
                  <p>Highest bus number that is on the downstream interface.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="IO_Base_Register" id="IO_Base_Register" width="8">
              <brief_description>PCI Express I/O Base Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 1 Header (RC mode).</p>
                <p>Note that this device does not support inbound I/O transactions. </p>
              </long_description>
              <address offset="0x1C"/>
              <reset_value value="0x1"/>
              <bit_field name="Address_Decode_Type" id="Address_Decode_Type" position="0" width="4" access="RO">
                <brief_description>Address Decode Type</brief_description>
                <long_description>
                  <p>Specifies the number of I/O address bits.</p>
                  <p>All other settings are reserved.</p>
                </long_description>
                <bit_field_value value="0x0">
                  <brief_description>16-bit I/O address decode</brief_description>
                </bit_field_value>
                <bit_field_value value="0x1">
                  <brief_description>32-bit I/O address decode</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="IO_Start_Address" id="IO_Start_Address" position="4" width="4" access="RW">
                <brief_description>I/O Start Address</brief_description>
                <long_description>
                  <p>Specifies bits 15:12 of the I/O space start address</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="IO_Limit_Register" id="IO_Limit_Register" width="8">
              <brief_description>PCI Express I/O Limit Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 1 Header (RC mode).</p>
                <p>Note that this device does not support inbound I/O transactions.</p>
              </long_description>
              <address offset="0x1D"/>
              <reset_value value="0x1"/>
              <bit_field name="Address_Decode_Type" id="Address_Decode_Type" position="0" width="4" access="RO">
                <brief_description>Address Decode Type</brief_description>
                <long_description>
                  <p>Specifies the number of I/O address bits.</p>
                  <p>All other settings are reserved.</p>
                </long_description>
                <bit_field_value value="0x0">
                  <brief_description>16-bit I/O address decode</brief_description>
                </bit_field_value>
                <bit_field_value value="0x1">
                  <brief_description>32-bit I/O address decode</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="IO_Limit_Address" id="IO_Limit_Address" position="4" width="4" access="RW">
                <brief_description>I/O Limit Address</brief_description>
                <long_description>
                  <p>Specifies bits 15:12 of the I/O space ending address</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Secondary_Status_Register" id="Secondary_Status_Register" width="16">
              <brief_description>PCI Express Secondary Status Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x1E"/>
              <reset_value value="0x0"/>
              <reserved_bit_field position="0" width="8" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="MDPE" id="MDPE" position="8" width="1" access="W1C">
                <brief_description>Master data parity error</brief_description>
                <long_description>
                  <p>This bit is set when the parity error response bit is set and the secondary side requester receives a poisoned
                    completion or poisons a write request. If the parity error response bit is cleared, this bit is never set.</p>
                </long_description>
              </bit_field>
              <reserved_bit_field position="9" width="2" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="STA" id="STA" position="11" width="1" access="W1C">
                <brief_description>Signaled target abort</brief_description>
                <long_description>
                  <p>This bit is set when the secondary side issues a CA completion.</p>
                </long_description>
              </bit_field>
              <bit_field name="RTA" id="RTA" position="12" width="1" access="W1C">
                <brief_description>Received target abort</brief_description>
                <long_description>
                  <p>This bit is set when the secondary side receives a completer abort (CA) completion.</p>
                </long_description>
              </bit_field>
              <bit_field name="RMA" id="RMA" position="13" width="1" access="W1C">
                <brief_description>Received master abort</brief_description>
                <long_description>
                  <p>This bit is set when the secondary side receives an unsupported request (UR) completion.</p>
                </long_description>
              </bit_field>
              <bit_field name="SSE" id="SSE" position="14" width="1" access="W1C">
                <brief_description>Signaled system error</brief_description>
                <long_description>
                  <p>This bit is set when a device sends a ERR_FATAL or ERR_NONFATAL message, provided the SERR enable bit in the
                    command register is set to enable reporting.</p>
                </long_description>
              </bit_field>
              <bit_field name="DPE" id="DPE" position="15" width="1" access="W1C">
                <brief_description>Detected parity error</brief_description>
                <long_description>
                  <p>This bit is set whenever the secondary side receives a poisoned TLP regardless of the state of the parity error
                    response bit.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Memory_Base_Register" id="Memory_Base_Register" width="16">
              <brief_description>PCI Express Memory Base Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x20"/>
              <reset_value value="0x0"/>
              <reserved_bit_field position="0" width="4" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="Memory_Base" id="Memory_Base" position="4" width="12" access="RW">
                <brief_description>Memory base address</brief_description>
                <long_description>
                  <p>Specifies bits 31:20 of the non-prefetchable memory space start address. Typically used for specifying
                    memory-mapped I/O space. </p>
                  <note>Inbound posted transactions hitting into the mem base/limit range are ignored; inbound non-posted
                    transactions hitting into the mem base/limit range results in an unsupported request response.</note>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Memory_Limit_Register" id="Memory_Limit_Register" width="16">
              <brief_description>PCI Express Memory Limit Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x22"/>
              <reset_value value="0x0"/>
              <reserved_bit_field position="0" width="4" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="Memory_Limit" id="Memory_Limit" position="4" width="12" access="RW">
                <brief_description>Memory limit address</brief_description>
                <long_description>
                  <p>Specifies bits 31:20 of the non-prefetchable memory space ending address. Typically used for specifying
                    memory-mapped I/O space. </p>
                  <note>Inbound posted transactions hitting into the mem base/limit range are ignored; inbound non-posted
                    transactions hitting into the mem base/limit range results in unsupported request response.</note>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Prefetchable_Memory_Base_Register" id="Prefetchable_Memory_Base_Register" width="16">
              <brief_description>PCI Express Prefetchable Memory Base Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x24"/>
              <reset_value value="0x1"/>
              <bit_field name="Address_Decode_Type" id="Address_Decode_Type" position="0" width="4" access="RO">
                <brief_description>Address Decode Type</brief_description>
                <long_description>
                  <p>Specifies the number of prefetchable memory address bits.</p>
                  <p>All other settings reserved.</p>
                </long_description>
                <bit_field_value value="0x0">
                  <brief_description>32-bit memory address decode</brief_description>
                </bit_field_value>
                <bit_field_value value="0x1">
                  <brief_description>64-bit memory address decode</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="PF_Memory_Base" id="PF_Memory_Base" position="4" width="12" access="RW">
                <brief_description>Prefetchable memory base address</brief_description>
                <long_description>
                  <p>Specifies bits 31:20 of the prefetchable memory space start address.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Prefetchable_Memory_Limit_Register" id="Prefetchable_Memory_Limit_Register" width="16">
              <brief_description>PCI Express Prefetchable Memory Limit Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x26"/>
              <reset_value value="0x1"/>
              <bit_field name="Address_Decode_Type" id="Address_Decode_Type" position="0" width="4" access="RO">
                <brief_description>Address decode type</brief_description>
                <long_description>
                  <p>Specifies the number of prefetchable memory address bits.</p>
                  <p>All other settings reserved.</p>
                </long_description>
                <bit_field_value value="0x0">
                  <brief_description>32-bit memory address decode</brief_description>
                </bit_field_value>
                <bit_field_value value="0x1">
                  <brief_description>64-bit memory address decode</brief_description>
                </bit_field_value>
              </bit_field>
              <bit_field name="PF_Memory_Limit" id="PF_Memory_Limit" position="4" width="12" access="RW">
                <brief_description>Prefetchable memory limit address</brief_description>
                <long_description>
                  <p>Specifies bits 31:20 of the prefetchable memory space ending address.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Prefetchable_Base_Upper_32_Bits_Register" id="Prefetchable_Base_Upper_32_Bits_Register" width="32">
              <brief_description>PCI Express Prefetchable Base Upper 32 Bits Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x28"/>
              <reset_value value="0x0"/>
              <bit_field name="PF_Base_Upper_32_Bits" id="PF_Base_Upper_32_Bits" position="0" width="32" access="RW">
                <brief_description>Prefetchable memory base address (upper portion)</brief_description>
                <long_description>
                  <p>Specifies bits 64:32 of the prefetchable memory space start address when the address decode type field in the
                    prefetchable memory base register is 0x01.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Prefetchable_Limit_Upper_32_Bits_Register" id="Prefetchable_Limit_Upper_32_Bits_Register" width="32">
              <brief_description>PCI Express Prefetchable Limit Upper 32 Bits Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x2C"/>
              <reset_value value="0x0"/>
              <bit_field name="PF_Limit_Upper_32_Bits" id="PF_Limit_Upper_32_Bits" position="0" width="32" access="RW">
                <brief_description>Prefetchable memory limit address (upper portion)</brief_description>
                <long_description>
                  <p>Specifies bits 64-32 of the prefetchable memory space ending address when the address decode type field in the
                    prefetchable memory limit register is 0x01.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="IO_Base_Upper_16_Bits_Register" id="IO_Base_Upper_16_Bits_Register" width="16">
              <brief_description>PCI Express I/O Base Upper 16 Bits Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 1 Header (RC mode).</p>
                <p>Note that this device does not support inbound I/O transactions. </p>
              </long_description>
              <address offset="0x30"/>
              <reset_value value="0x0"/>
              <bit_field name="IO_Base_Upper_16_Bits" id="IO_Base_Upper_16_Bits" position="0" width="16" access="RO">
                <brief_description>I/O base address (upper portion)</brief_description>
                <long_description>
                  <p>Specifies bits 31-16 of the I/O space start address when the address decode type field in the I/O base register
                    is 0x01.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="IO_Limit_Upper_16_Bits_Register" id="IO_Limit_Upper_16_Bits_Register" width="16">
              <brief_description>PCI Express I/O Limit Upper 16 Bits Register</brief_description>
              <long_description>
                <p>This register is present only in the Type 1 Header (RC mode).</p>
                <p>Note that this device does not support inbound I/O transactions. </p>
              </long_description>
              <address offset="0x32"/>
              <reset_value value="0x0"/>
              <bit_field name="IO_Limit_Upper_16_Bits" id="IO_Limit_Upper_16_Bits" position="0" width="16" access="RO">
                <brief_description>I/O limit address (upper portion)</brief_description>
                <long_description>
                  <p>Specifies bits 31-16 of the I/O space ending address when the address decode type field in the I/O limit
                    register is 0x01.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Expansion_ROM_BAR_Type1" id="Expansion_ROM_BAR_Type1" width="32">
              <brief_description>PCI Express Expansion ROM Base Address Register (RC-Mode)</brief_description>
              <long_description>
                <p>The Expansion ROM Base Address register is located at offset 0x38 in the Type 1 Header (RC mode).</p>
                
                <!-\-DMcQ - AXI SPEX does not have PEX_CSR1. CS2 access for Mask may be different depending on SoC.-\->
              </long_description>
              <address offset="0x38"/>
              <reset_value value="0x0"/>
              <bit_field name="ROMBAR_EN" id="ROMBAR_EN_T1" position="0" width="1" access="RW">
                <brief_description>Expansion ROM enable</brief_description>
                <long_description>
                  <p>This bit controls whether or not the device accepts accesses to its expansion ROM</p>
                </long_description>
                <bit_field_value value="0b0">
                  <brief_description>The expansion ROM address space is disabled.</brief_description>
                </bit_field_value>
                <bit_field_value value="0b1">
                  <brief_description>Address decoding is enabled.</brief_description>
                </bit_field_value>
              </bit_field>
              <reserved_bit_field position="1" width="10" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="ROM_Base_Address" id="ROM_Base_Address_T1" position="11" width="21" access="RW">
                <brief_description>Expansion ROM base address</brief_description>
                <long_description>
                  <p>Specifies bits 31:11 of the non-prefetchable expansion ROM space start address. Typically used for specifying
                    memory-mapped I/O space. The default size is 16M.</p>
                </long_description>
              </bit_field>
            </register_def>
            <register_def name="Bridge_Control_Register" id="Bridge_Control_Register" width="16">
              <brief_description>PCI Express Bridge Control Register</brief_description>
              <long_description>This register is present only in the Type 1 Header (RC mode).</long_description>
              <address offset="0x3E"/>
              <reset_value value="0x0"/>
              <bit_field name="PER" id="PER" position="0" width="1" access="RW">
                <brief_description>Parity error response</brief_description>
                <long_description>
                  <p>This bit controls the logging of poisoned TLPs in the Master Data Parity Error bit in the Secondary Status
                    register.</p>
                </long_description>
              </bit_field>
              <bit_field name="SERR_EN" id="SERR_EN" position="1" width="1" access="RW">
                <brief_description>SERR enable</brief_description>
                <long_description>
                  <p>This bit controls the propagation of ERR_COR, ERR_NONFATAL, and ERR_FATAL responses received on the secondary
                    side.</p>
                </long_description>
              </bit_field>
              <bit_field name="ISA_EN" id="ISA_EN" position="2" width="1" access="RW">
                <brief_description>ISA enable</brief_description>
                <long_description/>
              </bit_field>
              <bit_field name="VGA_EN" id="VGA_EN" position="3" width="1" access="RW">
                <brief_description>VGA enable</brief_description>
                <long_description/>
              </bit_field>
              <reserved_bit_field position="4" width="2" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
              <bit_field name="Scnd_RST" id="Scnd_RST" position="6" width="1" access="RW">
                <brief_description>Secondary bus reset</brief_description>
                <long_description/>
              </bit_field>
              <reserved_bit_field position="7" width="9" access="RU">
                <long_description>
                  <p>Reserved</p>
                </long_description>
              </reserved_bit_field>
            </register_def>
          </register_group>
        </alternate_register_groups>-->
        <!-- demos bit order flipping scenarios !!!
        <register_def name="PPCFG" id="PPCFG" width="32">
          <brief_description>Port Phy1Cfg register</brief_description>
          <address offset="0xA8"/>
          <reset_value value="0xABCD_0123"/>
          <bit_field name="TTA" id="TTA" position="0" width="32" access="RW"/>
        </register_def>
        <register_def name="FLIPPER0" id="PPCFG0" width="32">
          <brief_description>Port Phy1Cfg register</brief_description>
          <address offset="0xFFA8"/>
          <reset_value value="0xABCD_0123"/>
          <reserved_bit_field position="0" width="2" access="RU"/>
          <bit_field name="TTA" id="TTA" position="2" width="30" access="RW"/>
        </register_def>
        <register_def name="FLIPPER1" id="PPCFG1" width="32">
          <brief_description>Port Phy1Cfg register</brief_description>
          <address offset="0xFFFA8"/>
          <reset_value value="0xABCD_0123"/>
          <bit_field name="TTA" id="TTA" position="0" width="18" access="RW"/>
          <reserved_bit_field position="18" width="14" access="RU"/>
        </register_def>
        <register_def name="FLIPPER2" id="PPCFG2" width="32">
          <brief_description>Port Phy1Cfg register</brief_description>
          <address offset="0xFFFAF8"/>
          <reset_value value="0xABCD_0123"/>
          <reserved_bit_field position="0" width="2" access="RU"/>
          <bit_field name="TTA" id="TTA" position="2" width="28" access="RW"/>
          <reserved_bit_field position="30" width="2" access="RU"/>
        </register_def>
        <register_def name="FLIPPER3" id="PPCFG3" width="64">
          <brief_description>Port Phy1Cfg register</brief_description>
          <address offset="0xFFFFFFA8F"/>
          <reset_value value="0xABCD_0123_F0F0_0F0F"/>
          <reserved_bit_field position="0" width="2" access="RU"/>
          <bit_field name="TTA" id="TTA" position="2" width="60" access="RW"/>
          <reserved_bit_field position="62" width="2" access="RU"/>
        </register_def>-->
        <!-- tests "range" style bitfield values -->
        <!--<register_def name="range_values_reg" id="range_value_reg" width="16">
          <brief_description>range value register</brief_description>
          <address offset="0x0"/>
          <reset_value value="0xABCD"/>
          <bit_field position="0" width="4" access="RW" id="range_field" name="range_field">
            <brief_description>range field</brief_description>
            <bit_field_value value="0b0000-0b1111">
              <brief_description>all values in this range are valid.</brief_description>
            </bit_field_value>
          </bit_field>
          <reserved_bit_field position="4" width="12" access="RU"/>
        </register_def>-->
        <!-- tests 64 bit single-field regs -->
        <!--<register_def id="sap_exec_trans_48_sel" name="sap_exec_trans_48_sel" width="1222">
          <brief_description>SAP Execute Transaction 48</brief_description>
          <long_description>
            <p>Private SAP instruction that commands the TAP controller to load in the transaction
              configuration data and 48 bits of address into the 64-bit data shift register.</p>
          </long_description>
          <address offset="0xFFF"/>
          <reset_value value="0x0" mask="0x0"/>
          <bit_field id="sap_exec_trans_48" name="sap_exec_trans_48" position="0" width="1222"
            access="RW">
            <long_description>
              <p>See SAP blockguide for details.</p>
            </long_description>
          </bit_field>
        </register_def>-->
        <!--
        <register_def name="non_identical0" id="non_identical0" width="32" active="@(numeric_param &lt; 5)">
          <brief_description>test register for non-identical module instances</brief_description>
          <address offset="0x0"/>
          <reset_value value="0x400F7F" mask="0x400F7F"/>
          <bit_field id="test" name="test" position="0" width="32" access="RO">
            <brief_description>test</brief_description>
          </bit_field>
        </register_def>
        <register_def name="non_identical1" id="non_identical1" width="32">
          <brief_description>test register for non-identical module instances</brief_description>
          <long_description>This register should have different access types for different instances of this module.</long_description>
          <address offset="0x0F"/>
          <bit_field id="test" name="test" position="0" width="32" access="@(numeric_param &lt; 5 ? RO : RW)">
            <brief_description>test</brief_description>
          </bit_field>
        </register_def>-->
        <!--<register_array name="DMAn0"
          size="4"
          description="DMAn Registers">
          <autoinc_address offset="0x254" step="0x040"/>
          
          <int_iterator name="DMA" from="0"/>
          <int_iterator name="aliasAdrOffset" from="0x2D4" step="0x10"/>
          
          <register_alias_array name="DMA@[DMA]AIE" size="2">
            <autoinc_address offset="0x0" step="@[aliasAdrOffset]"/>
            <enum_iterator name="alias_name">
              <iterator_value>AIE</iterator_value>
              <iterator_value>_AID_15_0_EN_REG</iterator_value>
            </enum_iterator>
            <int_iterator name="alias_offset" from="0" step="-4"/>
            <register_def id="DMA@[DMA]@[alias_name]"
              name="DMA@[DMA]@[alias_name]"
              width="32">
              <brief_description>DMA@[DMA] AXI ID Enable Register</brief_description>
              <long_description>
                <p>The DMA AXI ID Enable register can be read to determine which AXI transaction IDs
                  are available for use by the DMAs. These enables are configured via hardwired
                  signals and are SOC-specific. The DMA will use a unique AXI ID for each
                  SEC internal connected to it. The assignments are made using the
                  lowest-numbered, available IDs.</p>
                
              </long_description>
              <address offset="@[alias_offset]"/>
              <reset_value value="0">
                <long_description>The values read are determined by hardwired inputs to
                  SEC</long_description>
              </reset_value>
              <bit_field id="AID0E" name="AID0E" position="0" width="1" access="RO">
                <long_description>
                  <p>If AID0E=1 then AXI ID 0 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID1E" name="AID1E" position="1" width="1" access="RO">
                <long_description>
                  <p>If AID1E=1 then AXI ID 1 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID2E" name="AID2E" position="2" width="1" access="RO">
                <long_description>
                  <p>If AID2E=1 then AXI ID 2 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID3E" name="AID3E" position="3" width="1" access="RO">
                <long_description>
                  <p>If AID3E=1 then AXI ID 3 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID4E" name="AID4E" position="4" width="1" access="RO">
                <long_description>
                  <p>If AID4E=1 then AXI ID 4 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID5E" name="AID5E" position="5" width="1" access="RO">
                <long_description>
                  <p>If AID5E=1 then AXI ID 5 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID6E" name="AID6E" position="6" width="1" access="RO">
                <long_description>
                  <p>If AID6E=1 then AXI ID 6 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID7E" name="AID7E" position="7" width="1" access="RO">
                <long_description>
                  <p>If AID7E=1 then AXI ID 7 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID8E" name="AID8E" position="8" width="1" access="RO">
                <long_description>
                  <p>If AID8E=1 then AXI ID 8 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID9E" name="AID9E" position="9" width="1" access="RO">
                <long_description>
                  <p>If AID9E=1 then AXI ID 9 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID10E"
                name="AID10E"
                position="10"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID10E=1 then AXI ID 10 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID11E"
                name="AID11E"
                position="11"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID11E=1 then AXI ID 11 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID12E"
                name="AID12E"
                position="12"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID12E=1 then AXI ID 12 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID13E"
                name="AID13E"
                position="13"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID13E=1 then AXI ID 13 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID14E"
                name="AID14E"
                position="14"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID14E=1 then AXI ID 14 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field id="AID15E"
                name="AID15E"
                position="15"
                width="1"
                access="RO">
                <long_description>
                  <p>If AID15E=1 then AXI ID 15 is enabled for this DMA engine.</p>
                </long_description>
              </bit_field>
              <bit_field position="16" width="16" access="RU">
                <long_description>
                  <p>Reserved.</p>
                </long_description>
              </bit_field>
            </register_def>
          </register_alias_array>
          <register_alias_array name="DMA@[DMA]ARL" size="2">
            <autoinc_address offset="0x018" step="@[aliasAdrOffset]"/>
            <enum_iterator name="alias_name">
              <iterator_value>ARL</iterator_value>
              <iterator_value>ARTC_LAT_REG</iterator_value>
            </enum_iterator>
            <int_iterator name="alias_offset" from="0" step="-4"/>
            <register_def id="DMA@[DMA]@[alias_name]"
              name="DMA@[DMA]@[alias_name]"
              width="32">
              <brief_description>DMA@[DMA] Read Timing Check Latency Register</brief_description>
              <long_description>
                <p>While AXI Read Timing Checks are enabled and not suspended, this register
                  maintains a running total of AXI read latencies.</p>
                
              </long_description>
              <address offset="@[alias_offset]"/>
              <bit_field id="SARL"
                name="SARL"
                position="0"
                width="32"
                access="RW">
                <long_description>
                  <p>Sum of the AXI Read Latencies. After each AXI read timing check, the latency is
                    added to the Sum of AXI Read Latencies (SARL) in DMAaARL. 
                  </p>
                </long_description>
                <reset_value value="0"/>
              </bit_field>
            </register_def>
          </register_alias_array>
          <register_alias_array name="DMA@[DMA]AWL" size="2">
            <autoinc_address offset="0x028" step="@[aliasAdrOffset]"/>
            <enum_iterator name="alias_name">
              <iterator_value>AWL</iterator_value>
              <iterator_value>AWTC_LAT_REG</iterator_value>
            </enum_iterator>
            <int_iterator name="alias_offset" from="0" step="-4"/>
            <register_def id="DMA@[DMA]@[alias_name]"
              name="DMA@[DMA]@[alias_name]"
              width="32">
              <brief_description>DMA@[DMA] Write Timing Check Latency Register</brief_description>
              <long_description>
                <p>While AXI Write Timing Checks are enabled and not suspended, this register
                  maintains a running total of AXI write latencies.</p>
                
              </long_description>
              <address offset="@[alias_offset]"/>
              <bit_field id="SAWL" name="SAWL" position="0" width="32" access="RO">
                <long_description>
                  <p>Sum of the AXI Write Latencies. After each AXI write timing check, the latency
                    is added to the Sum of AXI Write Latencies (SAWL). 
                  </p>
                </long_description>
                <reset_value value="0"/>
              </bit_field>
            </register_def>
          </register_alias_array>
        </register_array>-->
        <!--<register_def name="all_reserved" width="32">
          <brief_description>all reserved; should not output!</brief_description>
          <address offset="0x0"/>
          <reset_value value="0x0"/>
          <bit_field id="asdf" position="0" width="32" access="RU"></bit_field>
        </register_def>-->
        <!--<register_array name="Job_Ring_Registers"
          size="4">
          <autoinc_address offset="0x1000"
            step="0x1000"/>
          <int_iterator name="Job_Ring" from="0"/>
          <register_def id="IRBAR_JR@[Job_Ring]" name="IRBAR_JR@[Job_Ring]" width="8">
            <brief_description>Input Ring Base Address Register for Job Ring @[Job_Ring]</brief_description>
            <long_description>
              
              
              
              <p>
                
                 The IRBAR register can be written only when there are no jobs in the
                input ring or when the job ring is halted, else an input ring base address  invalid write error will result and a job ring
                reset or a power on reset will be required. Writing this register resets the Input
                Ring Read Index register, therefore following a write to the IRBAR the new head of the
                queue within the input ring will be located at the value just written to the IRBAR.
                Note that if the input ring was not empty, software must relocate the queue entries
                and write the number of these relocated entries to the Input Ring Jobs Added Register
                or these jobs will be lost. The address written to the Input Ring Base Address
                register must be 4-byte aligned, else an error will result and the job ring will not
                process jobs until a valid address is written and the error is cleared. More
                information on job management can be found in <xref href="/projects/QorIQ/shared_ip/caam/topics/job_ring_interface"/>.</p>
            </long_description>
            <address offset="0x0000">
                  <long_description>used by JR @[Job_Ring]. 

                          <ph>When the endianness is in the default configuration, this address is for the least-significant 32 bits.  The most-significant 32 bits can be accessed at this address +4h.</ph>
                          

                  </long_description>
               </address>
            <reset_value value="0"/>
            
            
            <bit_field id="asdf" name="asdf"
              position="0"
              width="8"
              access="RO">
              <long_description>
                <p>asdf</p>
              </long_description>
            </bit_field>
          </register_def>
        </register_array>-->
        <!--<register_def id="PC_OB_ENC_REQ"
          name="PC_OB_ENC_REQ"
          width="64">
          <brief_description>Performance Counter, Number of Outbound Encrypt Requests</brief_description>
          <long_description>
            <p>The PC_OB_ENC_REQ register counts the total number of requests for symmetric encryption
              (excluding requests associated with blob encapsulations and encryption of Black Keys).
              If a descriptor specifies an encryption operation, the register is incremented at the
              time that the encryption operation completes. Note that a single descriptor containing
              multiple encryption commands could cause this register to increment more than once. The
              LSB of the Class 1 Mode register determines if this register or PC_IB_DEC_REQ is
              incremented. To write this register, first write the 16 most-significant bits, then the
              32 least-significant bits. When the 16 most-significant bits are written, only an
              internal holding register is actually written. When the 32 least-significant bits are
              written, the 48-bit counter is loaded with a concatenation of the holding register and
              the 32-bit write data bus. To read, first read the 16 most-significant bits. This will
              also put the current value of the 32 least-significant bits in a holding register.
              Reading the 32 least-significant bits reads the holding register, not the actual counter.</p>
          </long_description>
          <address offset="0xF08">
               <brief_description>These addresses are for the least-significant 32 bits; the most significant 32 bits can be accessed at these addresses +4h.</brief_description>
            </address>
          <address offset="0x1F08"/>
          <address offset="0x2F08" />
          <address offset="0x3F08" />
          <address offset="0x4F08" />
          <address offset="0x6F08" />
          <address offset="0x7F08" />
          <address offset="0x8F08"/>
          <address offset="0x9F08" />
          <address offset="0xAF08" />
          <address offset="0xBF08" />
          <reset_value value="0"/>
          <bit_field id="PC_OB_ENC_REQ"
            name="PC_OB_ENC_REQ"
            position="0"
            width="48"
            access="RW">
            <long_description>
              <p>Performance Counter Outbound Encryption Requests.</p>
            </long_description>
          </bit_field>
          <bit_field id="" position="48" width="16" access="RU">
            <long_description>
              <p>Reserved.</p>
            </long_description>
          </bit_field>
        </register_def>-->

        <!--<register_array size="@(asdf)" name="test_array">
          <autoinc_address offset="0" step="4"/>
          <int_iterator name="index" from="0"/>
          <register_def id="test@[index]" width="32" name="test@[index]">
            <brief_description>test register @[index]</brief_description>
            <long_description><p>This register tests parameterized arrays sizes. This array should
                be size @(numeric_param).</p></long_description>
            <address offset="0"/>
            <reset_value value="0"/>
            <bit_field id="test_bf" name="test_bf" position="0" width="32" access="RO">
              <brief_description>test bitfield</brief_description>
            </bit_field>
          </register_def>
        </register_array>-->
        <!--<register_array name="AIJOBDRx" size="27"> <!-\- 2014/07/24 CAAM - register section title running off page due to large number of enum iterator values; CRR_JUL_24_2014 fixed by adding limit of 50 chars to generic full name -\->
          <autoinc_address offset="0x5574" step="4"/>
          <enum_iterator name="AI_JOB_DATA_REG">
            <string_iterator_value>34</string_iterator_value>
            <string_iterator_value>33</string_iterator_value>
            <string_iterator_value>32</string_iterator_value>
            <string_iterator_value>26</string_iterator_value>
            <string_iterator_value>25</string_iterator_value>
            <string_iterator_value>24</string_iterator_value>
            <string_iterator_value>23</string_iterator_value>
            <string_iterator_value>22</string_iterator_value>
            <string_iterator_value>21</string_iterator_value>
            <string_iterator_value>20</string_iterator_value>
            <string_iterator_value>19</string_iterator_value>
            <string_iterator_value>18</string_iterator_value>
            <string_iterator_value>17</string_iterator_value>
            <string_iterator_value>16</string_iterator_value>
            <string_iterator_value>15</string_iterator_value>
            <string_iterator_value>14</string_iterator_value>
            <string_iterator_value>13</string_iterator_value>
            <string_iterator_value>12</string_iterator_value>
            <string_iterator_value>11</string_iterator_value>
            <string_iterator_value>10</string_iterator_value>
            <string_iterator_value>9</string_iterator_value>
            <string_iterator_value>8</string_iterator_value>
            <string_iterator_value>7</string_iterator_value>
            <string_iterator_value>6</string_iterator_value>
            <string_iterator_value>5</string_iterator_value>
            <string_iterator_value>1</string_iterator_value>
            <string_iterator_value>0</string_iterator_value>
          </enum_iterator>

          <register_def id="AIJOBD@[AI_JOB_DATA_REG]" name="AIJOBD@[AI_JOB_DATA_REG]" width="32">
            <brief_description>AIOP Interface Job Register @[AI_JOB_DATA_REG]</brief_description>
            <long_description/>
            <address offset="0x0000">
                  <long_description>Used for debugging.</long_description>
               </address>
            <bit_field id="adsf" name="asdf" position="0" width="32" access="RW">
              <brief_description>asdf</brief_description>
            </bit_field>
          </register_def>
        </register_array>-->

        <!--<register_array name="asdf_KEY" size="16">
          <autoinc_address offset="0x0200" step="4"/>
          <int_iterator name="word" from="0"/>
          <register_def id="KEY_@[word]" name="KEY_@[word]" width="32" overridable="true">
            <brief_description> Key Registers</brief_description>
            <long_description>
              <p>The Key Register normally holds the left-aligned key for the internal crypto
                engine. The MSB is in offset 200h. The Key Register is bits in length. The IP bus
                write to the Context Register is accessible only as full-word reads or writes to
                four 32-bit registers. </p>
              <p> Before the value in the Key Register can be used in a cryptographic operation, the
                size of the key must be written into the Key Size Register. Once the Key Size
                Register has been written, the Key Register cannot be written again until the Key
                Size Register has been cleared. </p>
            </long_description>
            <address offset="0"/>
            <bit_field id="KEYR" name="KEYR" position="0" width="32" access="RW">
              <long_description>
                <p>KEYR</p>
              </long_description>
              <reset_value value="0"/>
            </bit_field>
          </register_def>
        </register_array>-->
        <!--<register_def id="DMAARTC" name="DMAARTC" width="64">
          <brief_description>DMA AXI Read Timing Check Register</brief_description>
          <long_description>
            <p>When AXI Read Timing Checks are enabled, the DMA measures the latencies of selected
              AXI read transactions. A timer measures the latency by counting the number of AXI
              clock cycles from the read address transaction to the beginning of the corresponding
              read data transaction. The sample count is incremented and, if the latency equals or
              exceeds the programmed limit, the late count is incremented. The latency value is
              added to the running total of latencies. After completion of each timing check, the
              process is repeated for the next AXI read. Timing checks are suspended when:</p>
            <ul>
              <li>the AXI read sample count value reaches FFFFFh, or</li>
              <li>the AXI read latency total reaches FFFFFFFFh, or</li>
              <li>the AXI Read Timing Check Register is read </li>
            </ul>
            <p>After the AXI Read Latency Register is read, the sample count, late count, and
              latency total are cleared and read timing checks resume with the next AXI read. </p>
            
          </long_description>
          <address offset="0x020"/>
          <reset_value value="0"/>
          <bit_field id="ARSC" name="ARSC" position="0" width="20" access="RW">
            <long_description>
              <p>AXI Read Sample Count. This field is incremented after each read timing check.
                AXI read timing checks are suspended when ARSC=0xFFFFF. .</p>
            </long_description>
          </bit_field>
          <reserved_bit_field id="" position="20" width="4" access="RU">
            <long_description>
              <p>Reserved.</p>
            </long_description>
          </reserved_bit_field>
          <bit_field id="ARLC_LS"
            name="ARLC_LS"
            position="24"
            width="8"
            access="RW">
            <long_description>
              <p>AXI Read Late Count, 8 ls bits. This field is incremented whenever the AXI Read
                Timer equals or exceeds the AXI Read Limit. AXI read timing checks are suspended
                when ARLC=0xFFFFF. . </p>
            </long_description>
          </bit_field>
          <bit_field id="ARLC_MS"
            name="ARLC_MS"
            position="32"
            width="12"
            access="RW">
            <long_description>
              <p>AXI Read Late Count, 12 ms bits. This field is incremented whenever the AXI Read
                Timer equals or exceeds the AXI Read Limit. AXI read timing checks are suspended
                when ARLC=0xFFFFF. 
              </p>
            </long_description>
          </bit_field>
          <bit_field id="" position="44" width="4" access="RU">
            <long_description>
              <p>Reserved.</p>
            </long_description>
          </bit_field>
          <bit_field id="ARL" name="ARL" position="48" width="12" access="RW">
            <long_description>
              <p>AXI Read Limit. The AXI Read Timer measures latency by counting the number of AXI
                clock cycles from the AXI read address transaction to the beginning of the
                corresponding read data transaction. If the latency equals or exceeds the AXI Read
                Limit, the read response is considered late and the AXI Read Late Count (ARLC) is
                incremented along with the AXI Read Sample Count (ARSC). The latency is added to
                the Sum of AXI Read Latencies (SARL) in DMAaARL. 
              </p>
            </long_description>
          </bit_field>
          <bit_field id="ARCT"
            name="ARCT"
            position="60"
            width="3"
            access="RW">
            <long_description>
              <p>AXI Read Counter Test. When 1, ARLC and ARSC in DMAaARTC
                and SARL in DMAaARL are not
                cleared when timing checks are enabled and when timing checks resume after reading
                DMAaARTC and DMAaARL. This bit is used only for
                manufacturing test. It allows the counters to be intialized to non-zero values for
                the start of timing checks. This shortens the counting range so that terminal
                count behavior can be tested.</p>
            </long_description>
          </bit_field>
          <bit_field id="ARTCE" name="ARTCE" position="63" width="1" access="RW">
            <long_description>
              <p>AXI Read Timing Check Enable. When ARTCE=0, ARL, ARLC, and ARSC in DMAaARTC and
                SARL in DMAaARL are
                writeable. When ARTCE=1, AXI read timing checks are enabled and these fields are
                read-only.
              </p>
            </long_description>
          </bit_field>
        </register_def>-->

        <!--<register_array name="MPPKR_i"
                            size="16"
                            >
               <autoinc_address offset="0x300" step="4"/>
               <int_iterator name="i" from="0"/>
               <register_def id="MPPKR_@[i]" name="MPPKR_@[i]" width="32">
                  <brief_description>Manufacturing Protection Private Key Register</brief_description>
                  <long_description>
                     <p>The Manufacturing Protection Private Key register is used when authenticating the
                SOC to the OEM's server. This authentication process can be used to ensure that the
                SOC is a genuine Freescale part, is the correct part type, has been properly
                configured via fuses, is running authenticated OEM software, and is currently in the
                Secure or Trusted mode. The SOC attests to all this by signing a message using the
                private key stored in the MPPKR. Software running on the SOC then sends this
                attestation message to the OEM's server. The OEM's server can verify that all this
                information is correct by verifying the signature over the signed message. The
                server can then be assured that it is safe to download proprietary data to the SOC
                over a secured connection.</p>
                     
                     
                  </long_description>
                  <address offset="0x000"/>
                  <reset_value value="0"/>
                  <bit_field id="MPPrivK"
                             name="MPPrivK"
                             position="0"
                             width="32"
                             access="RW">
                     <long_description>
                        <p>MPPrivK</p>
                     </long_description>
                  </bit_field>
               </register_def>
            </register_array>-->

        <!--<register_array size="17" name="test_array">
          <autoinc_address offset="0x0" step="0x4"/>
          <int_iterator name="index" from="0"/>
          <register_def width="32" name="test_reg@[index]" id="test_reg@[index]" overridable="false">
            <brief_description>test register @[index]</brief_description>
            <address offset="0"><long_description>used for word @[index]</long_description></address>
            <reset_value value="0"/>
            <bit_field position="0" width="32" access="RO" id="IPn" name="IPn">
              <brief_description>some IP field</brief_description>
            </bit_field>
          </register_def>
        </register_array>-->


        <!-- FUBAR - RESET value output to REG FIG testing -->
        <!--<register_def width="32" id="test_reg0" name="test_reg0">
          <brief_description>test_reg_brief</brief_description>
          <address offset="0x0"/>
          <reset_value value="0x400F7F" mask="0x400F7F"/>
          <bit_field position="0" width="16" access="RO" id="test_bf0" name="test_bf0">
            <brief_description>T0</brief_description>
            <long_description><p>Test Field 0</p></long_description>
          </bit_field>
          <bit_field position="16" width="16" access="RO" id="test_bf1" name="test_bf1">
            <brief_description>T1</brief_description>
            <long_description>Test Field 1</long_description>
          </bit_field>
          
          <bit_field_group>
            <brief_description>Test Field Group</brief_description>
            <long_description><p>A test bitfield group.</p></long_description>
            <bit_field_ref id="test_bf0"/>
            <bit_field_ref id="test_bf1"/>
            <bit_field_value value="0x00000000"><brief_description>Min value for T0 and T1</brief_description></bit_field_value>
            <bit_field_value value="0xFFFFFFFF"><brief_description>Max value for T0 and T1</brief_description></bit_field_value>
          </bit_field_group>
        </register_def>-->
        <!--<register_def width="64" id="test_reg1" name="test_reg1">
          <brief_description>test_reg_brief</brief_description>
          <address offset="0x0"/>
          <reset_value value="0x0123456789ABCDEF"/>
          <bit_field position="0" width="8" access="RO" id="test_bf0" name="test_bf0">
            <brief_description>T0</brief_description>
            <long_description><p>Test Field 0</p></long_description>
          </bit_field>
          <bit_field position="8" width="48" access="RO" id="test_bf1" name="test_bf1">
            <brief_description>T1</brief_description>
            <long_description>Test Field 1</long_description>
          </bit_field>
          <bit_field position="56" width="8" access="RO" id="test_bf2" name="test_bf2">
            <brief_description>T2</brief_description>
            <long_description>Test Field 2</long_description>
            <bit_field_value value="00"><brief_description>value outcome 1</brief_description></bit_field_value>
            <bit_field_value value="01"><brief_description>value outcome 2</brief_description></bit_field_value>
            <bit_field_value value="10"><brief_description>value outcome 3</brief_description></bit_field_value>
            <bit_field_value value="11"><brief_description>value outcome 4</brief_description></bit_field_value>
          </bit_field>
        </register_def>-->
        <!--<register_def width="32" id="test_reg2" name="test_reg2">
          <brief_description>test_reg_brief</brief_description>
          <address offset="0x0"/>
          <reset_value value="0x400F7F" mask="0x400F7F"/>
          <bit_field position="0" width="31" access="RO" id="test_bf0" name="test_bf0">
            <brief_description>T0</brief_description>
            <long_description><p>Test Field 0</p></long_description>
          </bit_field>
          <bit_field position="31" width="1" access="RO" id="test_bf1" name="test_bf1">
            <brief_description>T1</brief_description>
            <long_description>Test Field 1</long_description>
          </bit_field>
        </register_def>-->
        <!--<register_def id="FUSESR" name="FUSESR" width="32">
          <brief_description>Fuse Status Register</brief_description>
          <long_description>
            <p>The fuse status register provides the values from on-chip voltage ID efuses
              programmed at the factory. These values define the voltage requirements for the chip.
              Boot software reads FUSESR and translates the values into the appropriate commands to
              set the voltage output value of an external voltage regulator.</p>
          </long_description>
          <address offset="0xFFFFFF"/>
          <bit_field id="DC_ALT_V" name="DC_ALT_V" position="0" width="5" access="RO">
            <brief_description>Domain C Alternate Voltage</brief_description>
            <long_description>
              <p>This is a secondary voltage field for domain C. The
                field encodings are the same as DA_ALT_V.</p>
            </long_description>
            <reset_value value="0x1"/>
          </bit_field>
          <bit_field id="DC_V" name="DC_V" position="5" width="5" access="RO">
            <long_description>
              <p>Domain C voltage. This is the minimum voltage required to reach the frequency
                specified by the speed bin for the IP in this domain. Note that most of the possible
                voltages levels will never be specified by the factory. The field encodings are the
                same as DA_V, except 11111 is defined as "Use value in DC_ALT_V field."</p>
            </long_description>
            <reset_value value="0x2"/>
          </bit_field>
          <bit_field id="DB_ALT_V" name="DB_ALT_V" position="10" width="5" access="RO">
            <long_description>
              <p>Domain B alternate voltage. This is a secondary voltage field for domain B. The
                field encodings are the same as DA_ALT_V.</p>
            </long_description>
            <reset_value value="0x3"/>
          </bit_field>
          <bit_field id="DB_V" name="DB_V" position="15" width="5" access="RO">
            <long_description>
              <p>Domain B voltage. This is the minimum voltage required to reach the frequency
                specified by the speed bin for the IP in this domain. Note that most of the possible
                voltages levels will never be specified by the factory. The field encodings are the
                same as DA_V, except 11111 is defined as "Use value in DB_ALT_V field."</p>
            </long_description>
            <reset_value value="0x4"/>
          </bit_field>
          <bit_field id="DA_ALT_V" name="DA_ALT_V" position="20" width="5" access="RO">
            <long_description>asdf </long_description>
            <reset_value value="0x5"/>
          </bit_field>
          <bit_field id="DA_V" name="DA_V" position="25" width="5" access="RO">
            <long_description>fddf </long_description>
            <reset_value value="0x6"/>
          </bit_field>
          <bit_field id="DA_Vsdfd" name="DA_Vfsddf" position="30" width="2" access="RO">
            <long_description>fdddddf </long_description>
            <reset_value value="0x0"/>
          </bit_field>
          

        </register_def>-->
        <!-- <!-\- FUBAR - MASK BITS TEST CASE 14/06/09 -\-> 
        <register_array size="@(number_of_pcc_regs)" name="PCC" active="@(internal)"> <!-\- note that this array is conditionally sized -\->
          <autoinc_address offset="0x0A00" step="0x4"/>
          <enum_iterator name="reg_name"> <!-\- these values will be the hard-coded register names -\->
            <iterator_value>alpha</iterator_value>
            <iterator_value>bravo</iterator_value>
            <iterator_value>charlie</iterator_value>
          </enum_iterator>
          <int_iterator name="index" from="0"/> <!-\- this will be used to bitshift the mask to conditionalize individual array instances' existence -\->
          <!-\- note that you need to have an iterator (does not matter which one) to target individual array instances for SOC overrides -\->
          <register_def width="32" name="PCC_@[reg_name]" id="PCC_@[index]" overridable="true" exists="@[(@(mask_bits) &gt;&gt; index) % 2 == 1 ? true : false]">
            <brief_description>PCC @[reg_name] Register</brief_description> <!-\- equivalent to SIDSC "full name" and should include register name iterator -\->
            <long_description>PCC Register</long_description> <!-\- currently does not allow iterators but I will modify generator if there is a need -\->
            <address offset="0x0"/>
            <reset_value value="0x40000000"/>
            
            <bit_field name="EN" position="31" width="1" access="RO">
              <brief_description>Enable</brief_description>
              <long_description><p>This bit enables...</p></long_description>
              <bit_field_value value="0">
                <brief_description>disable</brief_description>
              </bit_field_value>
              <bit_field_value value="1">
                <brief_description>enable</brief_description>
              </bit_field_value>
            </bit_field>
            <bit_field position="0" width="31" access="RU"></bit_field>
          </register_def>
        </register_array> -->
      </address_block>

    </register_defs>
  </GeneralPeriphery>
</crr:UniversalDevice>
<!--EOF-->
